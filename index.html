<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Bumble Lite</title>
  <style>
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body { margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #0b0b0c; color: #f5f6f7; }
:root { --accent: #f7b500; --super-accent: #42a5f5; --muted: #9aa0a6; }
#app { min-height: 100svh; display: grid; place-items: stretch; }
.screen { display: none; padding: 16px; max-width: 640px; margin: 0 auto; }
.screen.visible { display: block; }

h1 { font-size: 28px; margin: 16px 0 8px; }
h2 { font-size: 18px; margin: 16px 0 8px; }
.sub { color: var(--muted); margin-bottom: 24px; }

label { display: block; font-size: 14px; margin: 8px 0 4px; color: #dfe1e5; }
input { width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #2a2a2b; background: #141416; color: #fff; }
input:focus { outline: 2px solid var(--accent); border-color: transparent; }

.btn { appearance: none; border: none; border-radius: 999px; padding: 12px 18px; background: #1f1f22; color: #fff; font-weight: 600; cursor: pointer; }
.btn.primary { background: var(--accent); color: #191919; }
.btn.super { background: var(--super-accent); color: #fff; }
.btn:active { transform: translateY(1px); }
.icon-btn { background: transparent; border: 1px solid #2a2a2b; border-radius: 10px; padding: 8px 10px; color: #e8eaed; cursor: pointer; }

.topbar { position: sticky; top: 0; display: flex; align-items: center; gap: 8px; padding: 8px 0 12px; background: #0b0b0c; z-index: 5; }
.brand { font-weight: 800; letter-spacing: 0.3px; }
.spacer { flex: 1; }

.content { display: grid; gap: 24px; }
.card-area { display: grid; gap: 12px; }
.card { border-radius: 18px; overflow: hidden; border: 1px solid #2a2a2b; background: #0f0f10; min-height: 55svh; display: grid; grid-template-rows: 1fr auto; touch-action: pan-y; }
.card img { width: 100%; height: 100%; object-fit: cover; background: #0b0b0c; }
.card-footer { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 40%, rgba(0,0,0,0.8) 100%); margin-top: -72px; }
.name-wrapper { font-weight: 700; text-shadow: 0 1px 8px rgba(0,0,0,0.7); }

.actions { display: flex; gap: 12px; justify-content: center; align-items: center; }
.muted { color: var(--muted); }
.small { font-size: 12px; }

.upload-area { border-top: 1px dashed #2a2a2b; padding-top: 16px; }

.status { min-height: 20px; font-size: 13px; color: #c4f1c4; }

.hint { margin-top: 8px; color: var(--muted); }
.hint summary { cursor: pointer; }

.gesture-hint { text-align: center; font-size: 12px; color: var(--muted); margin-top: 8px; }

/* Dialog */
dialog { border: 1px solid #2a2a2b; background: #111114; color: #fff; border-radius: 16px; padding: 16px; max-width: 520px; width: 92vw; }
dialog::backdrop { background: rgba(0,0,0,0.6); }
.row { display: flex; gap: 12px; margin-top: 12px; }

/* Gestures */
.swipe-right { animation: swipeR 250ms ease-out forwards; }
.super-like { animation: superLike 250ms ease-out forwards; }
@keyframes swipeR {
  to { transform: translateX(40vw) rotate(10deg); opacity: 0; }
}
@keyframes superLike {
  to { transform: translateY(-40vh) scale(1.1); opacity: 0; }
}

@media (min-width: 600px) {
  .card { min-height: 60vh; }
}
  </style>
</head>
<body>
  <div id="app">
    <!-- Login Screen -->
    <section id="login-screen" class="screen visible">
      <h1>bumble‚Äëlite</h1>
      <p class="sub">Only two users. Only right swipes.</p>
      <form id="login-form">
        <label>Username</label>
        <input id="username" name="username" autocomplete="username" placeholder="hardik or ananya" required />
        <label>Password</label>
        <input id="password" name="password" type="password" autocomplete="current-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" required />
        <button type="submit" class="btn primary">Log in</button>
      </form>
      <details class="hint">
        <summary>Hint</summary>
        <div><code>hardik / iloveananya</code> or <code>ananya / ilovehardik</code></div>
      </details>
    </section>

    <!-- Main App -->
    <section id="main-screen" class="screen">
      <header class="topbar">
        <div class="brand">bumble‚Äëlite</div>
        <div class="spacer"></div>
        <button id="open-settings" aria-label="Settings" class="icon-btn">‚öôÔ∏è</button>
        <button id="logout" class="icon-btn" aria-label="Log out">üö™</button>
      </header>

      <div class="content">
        <div class="card-area">
          <div id="card" class="card" tabindex="0" aria-live="polite">
            <img id="card-img" alt="Profile image" />
            <div class="card-footer">
              <div class="name-wrapper">
                <span id="other-username"></span>
              </div>
            </div>
          </div>
          <div class="actions">
            <button id="like-btn" class="btn primary">‚ù§Ô∏è Like</button>
            <button id="super-like-btn" class="btn super">‚≠ê Super Like</button>
            <button id="next-btn" class="btn">Next</button>
          </div>
          <div class="gesture-hint">Swipe right to like ‚Ä¢ Swipe up for super like</div>
          <div id="empty-feed" class="muted" hidden>No images yet. Ask the other user to upload!</div>
        </div>

        <div class="upload-area">
          <h2>Upload your photos</h2>
          <input id="file-input" type="file" accept="image/*" multiple />
          <button id="upload-btn" class="btn">Upload</button>
          <div class="muted small">Images up to 5MB will be auto-compressed to fit GitHub's 1MB limit. Saved to <code>/images/&lt;your-username&gt;/</code> in your GitHub repo if a token is configured. Otherwise stored locally only.</div>
          <div id="upload-status" class="status"></div>
        </div>
      </div>
    </section>

    <!-- Settings Modal -->
    <dialog id="settings-dialog">
      <form method="dialog" id="settings-form">
        <h3>Repository Settings</h3>
        <label>Owner (user/org)
          <input id="gh-owner" placeholder="your-github-username" required />
        </label>
        <label>Repo
          <input id="gh-repo" placeholder="your-repo-name" required />
        </label>
        <label>Branch
          <input id="gh-branch" placeholder="main" value="main" required />
        </label>
        <label>GitHub Token (fine-grained with Contents: Read &amp; Write for this repo)
          <input id="gh-token" type="password" placeholder="ghp_..." />
        </label>
        <div class="row">
          <button type="submit" class="btn primary">Save</button>
          <button value="cancel" class="btn">Close</button>
        </div>
        <p class="muted small">Token is stored in <code>localStorage</code> on this device only.</p>
      </form>
    </dialog>
  </div>

  <script>
// bumble-lite front-end
(function(){
  const el = (id) => document.getElementById(id);
  const loginScreen = el('login-screen');
  const mainScreen = el('main-screen');
  const loginForm = el('login-form');
  const usernameInput = el('username');
  const passwordInput = el('password');
  const otherUsername = el('other-username');
  const likeBtn = el('like-btn');
  const superLikeBtn = el('super-like-btn');
  const nextBtn = el('next-btn');
  const card = el('card');
  const cardImg = el('card-img');
  const emptyFeed = el('empty-feed');
  const fileInput = el('file-input');
  const uploadBtn = el('upload-btn');
  const uploadStatus = el('upload-status');
  const openSettings = el('open-settings');
  const settingsDialog = el('settings-dialog');
  const settingsForm = el('settings-form');
  const ghOwner = el('gh-owner');
  const ghRepo = el('gh-repo');
  const ghBranch = el('gh-branch');
  const ghToken = el('gh-token');
  const logoutBtn = el('logout');

  // --- App State ---
  let state = {
    me: null,                // 'hardik' | 'ananya'
    other: null,             // opposite of 'me'
    feed: [],                // array of image URLs
    feedIdx: 0,              // current index
    repo: { owner: '', repo: '', branch: 'main', token: '' }
  };

  // Try to infer owner/repo from GitHub Pages URL
  function inferRepoFromLocation(){
    // https://<owner>.github.io/<repo>/...
    const { host, pathname } = window.location;
    const m = host.match(/^([^.]+)\.github\.io$/);
    const pathParts = pathname.replace(/^\//,'').split('/').filter(Boolean);
    if(m && pathParts.length){
      return { owner: m[1], repo: pathParts[0] };
    }
    return null;
  }

  // Load repo settings from localStorage
  function loadRepoSettings(){
    const saved = localStorage.getItem('ghRepoCfg');
    if(saved){
      try { state.repo = JSON.parse(saved); } catch(e){}
    } else {
      const inferred = inferRepoFromLocation();
      state.repo = {
        owner: inferred?.owner || '',
        repo: inferred?.repo || '',
        branch: 'main',
        token: ''
      };
    }
    ghOwner.value = state.repo.owner || '';
    ghRepo.value = state.repo.repo || '';
    ghBranch.value = state.repo.branch || 'main';
    ghToken.value = state.repo.token || '';
  }
  function saveRepoSettings(){
    state.repo.owner = ghOwner.value.trim();
    state.repo.repo = ghRepo.value.trim();
    state.repo.branch = ghBranch.value.trim() || 'main';
    state.repo.token = ghToken.value.trim();
    localStorage.setItem('ghRepoCfg', JSON.stringify(state.repo));
  }

  // --- Auth (two fixed accounts) ---
  const USERS = {
    'hardik': 'iloveananya',
    'ananya': 'ilovehardik'
  };
  function persistSession(){
    localStorage.setItem('bumbleLiteSession', JSON.stringify({ me: state.me, ts: Date.now() }));
  }
  function loadSession(){
    try{
      const s = JSON.parse(localStorage.getItem('bumbleLiteSession')||'null');
      if(s?.me && USERS[s.me]){
        state.me = s.me;
        state.other = (state.me === 'hardik') ? 'ananya' : 'hardik';
        return true;
      }
    } catch(e){}
    return false;
  }
  function clearSession(){
    localStorage.removeItem('bumbleLiteSession');
  }

  // --- Image compression utilities ---
  function compressImage(file, maxSizeKB = 1000, quality = 0.8) {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        // Calculate new dimensions to stay under size limit
        let { width, height } = img;
        const maxDim = 1920; // Max dimension
        
        if (width > maxDim || height > maxDim) {
          if (width > height) {
            height = (height * maxDim) / width;
            width = maxDim;
          } else {
            width = (width * maxDim) / height;
            height = maxDim;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        
        ctx.drawImage(img, 0, 0, width, height);
        
        // Try different quality levels to stay under size limit
        const tryCompress = (q) => {
          canvas.toBlob((blob) => {
            if (blob && blob.size <= maxSizeKB * 1024) {
              // Convert blob back to File
              const compressedFile = new File([blob], file.name, {
                type: blob.type,
                lastModified: Date.now()
              });
              resolve(compressedFile);
            } else if (q > 0.1) {
              tryCompress(q - 0.1);
            } else {
              // If we can't compress enough, return original
              resolve(file);
            }
          }, file.type, q);
        };
        
        tryCompress(quality);
      };
      
      img.src = URL.createObjectURL(file);
    });
  }

  // --- GitHub API helpers ---
  const GH_API = 'https://api.github.com';

  async function githubListImages(user){
    const path = `images/${user}`;
    if(!state.repo.owner || !state.repo.repo){
      // No repo configured, try local fallback
      return listLocalImages(user);
    }
    const url = `${GH_API}/repos/${state.repo.owner}/${state.repo.repo}/contents/${encodeURIComponent(path)}?r=${Date.now()}`;
    const resp = await fetch(url, { headers: { 'Accept': 'application/vnd.github+json' } });
    if(resp.status === 404){
      return []; // folder not found yet
    }
    if(!resp.ok){
      console.warn('GitHub list error', resp.status);
      throw new Error('Failed to list images from GitHub');
    }
    const data = await resp.json();
    // Filter images and map to download_url
    return (Array.isArray(data) ? data : [])
      .filter(it => /(\.png|\.jpg|\.jpeg|\.webp|\.gif)$/i.test(it.name))
      .map(it => it.download_url);
  }

  async function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error('Read error'));
      reader.onload = () => {
        const res = reader.result || '';
        // res is like "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ..."
        const base64 = String(res).split(',')[1] || '';
        resolve(base64);
      };
      reader.readAsDataURL(file);
    });
  }
  
  async function githubUploadImage(user, file){
    if(!state.repo.token || !state.repo.owner || !state.repo.repo){
      // local fallback only
      return localSave(user, file);
    }
    
    // Compress image if it's too large
    let processedFile = file;
    if (file.size > 1000 * 1024) { // If larger than 1MB
      uploadStatus.textContent = 'Compressing image...';
      processedFile = await compressImage(file);
    }
    
    const base64 = await fileToBase64(processedFile);
    const safeName = `${Date.now()}-${file.name.replace(/[^a-z0-9_.-]/gi,'_')}`;
    const path = `images/${user}/${safeName}`;
    const url = `${GH_API}/repos/${state.repo.owner}/${state.repo.repo}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: `chore: add ${user} image ${safeName}`,
      content: base64,
      branch: state.repo.branch
    };
    const resp = await fetch(url, {
      method: 'PUT',
      headers: {
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.repo.token}`
      },
      body: JSON.stringify(body)
    });
    if(!resp.ok){
      const t = await resp.text();
      throw new Error(`GitHub upload failed: ${resp.status} ${t}`);
    }
    return true;
  }

  // Local fallback (non-persistent to GitHub; stays in this browser)
  function localKey(user){ return `localImages_${user}`; }
  async function localSave(user, file){
    const reader = new FileReader();
    const res = await new Promise((resolve, reject) => {
      reader.onerror = () => reject(new Error('Read error'));
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });
    const arr = JSON.parse(localStorage.getItem(localKey(user)) || '[]');
    arr.push(res);
    localStorage.setItem(localKey(user), JSON.stringify(arr));
    return true;
  }
  function listLocalImages(user){
    const arr = JSON.parse(localStorage.getItem(localKey(user)) || '[]');
    return arr;
  }

  // --- Feed logic ---
  async function loadFeed(){
    otherUsername.textContent = state.other;
    try {
      const imgs = await githubListImages(state.other);
      state.feed = imgs;
      state.feedIdx = 0;
      renderCard();
    } catch(e){
      console.error(e);
      state.feed = [];
      state.feedIdx = 0;
      renderCard();
    }
  }

  function renderCard(){
    if(!state.feed.length || state.feedIdx >= state.feed.length){
      cardImg.removeAttribute('src');
      emptyFeed.hidden = false;
      return;
    }
    emptyFeed.hidden = true;
    cardImg.src = state.feed[state.feedIdx];
  }

  function nextCard(){
    state.feedIdx = Math.min(state.feedIdx + 1, state.feed.length);
    renderCard();
  }

  function likeCurrent(isSuper = false){
    if(!state.feed.length || state.feedIdx >= state.feed.length) return;
    const img = state.feed[state.feedIdx];
    
    // Store like locally per user
    const k = isSuper ? `superlikes_${state.me}` : `likes_${state.me}`;
    const likes = JSON.parse(localStorage.getItem(k) || '[]');
    if(!likes.includes(img)) likes.push(img);
    localStorage.setItem(k, JSON.stringify(likes));

    // Animate and go next
    const animClass = isSuper ? 'super-like' : 'swipe-right';
    card.classList.remove('swipe-right', 'super-like');
    void card.offsetWidth; // reflow
    card.classList.add(animClass);
    setTimeout(() => {
      card.classList.remove(animClass);
      nextCard();
    }, 250);
  }

  // --- Touch gestures (right swipe and swipe up for super like) ---
  let touchStartX = null, touchStartY = null;
  card.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    touchStartX = t.clientX; touchStartY = t.clientY;
  }, {passive: true});
  
  card.addEventListener('touchend', (e) => {
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = touchStartY - t.clientY; // Inverted for upward swipe
    const horizontalDistance = Math.abs(dx);
    const verticalDistance = Math.abs(dy);
    
    if (dy > 60 && verticalDistance > horizontalDistance) {
      // Swipe up for super like
      likeCurrent(true);
    } else if (dx > 40 && horizontalDistance > verticalDistance) {
      // Right swipe for regular like
      likeCurrent(false);
    }
  }, {passive: true});

  // --- UI Events ---
  loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const u = usernameInput.value.trim().toLowerCase();
    const p = passwordInput.value;
    if(USERS[u] && USERS[u] === p){
      state.me = u;
      state.other = (u === 'hardik') ? 'ananya' : 'hardik';
      persistSession();
      loginScreen.classList.remove('visible');
      mainScreen.classList.add('visible');
      loadFeed();
    } else {
      alert('Invalid credentials');
    }
  });

  likeBtn.addEventListener('click', () => likeCurrent(false));
  superLikeBtn.addEventListener('click', () => likeCurrent(true));
  nextBtn.addEventListener('click', nextCard);

  uploadBtn.addEventListener('click', async () => {
    if(!state.me){ alert('Please log in first'); return; }
    const files = fileInput.files;
    if(!files || !files.length){ alert('Pick image(s) first'); return; }
    
    // Check file sizes
    const oversizedFiles = Array.from(files).filter(file => file.size > 5 * 1024 * 1024); // 5MB limit
    if (oversizedFiles.length > 0) {
      alert(`Some files are too large (>5MB): ${oversizedFiles.map(f => f.name).join(', ')}`);
      return;
    }
    
    uploadStatus.textContent = 'Uploading...';
    let ok = 0, fail = 0;
    for(const file of files){
      try{
        await githubUploadImage(state.me, file);
        ok++;
        uploadStatus.textContent = `Uploaded ${ok}/${files.length} files...`;
      } catch(err){
        console.error(err);
        fail++;
      }
    }
    uploadStatus.textContent = (state.repo.token && state.repo.owner && state.repo.repo)
      ? `Uploaded ${ok} file(s) to GitHub. ${fail ? fail+' failed.' : ''}`
      : `Saved ${ok} locally (no GitHub token configured). ${fail ? fail+' failed.' : ''}`;
    fileInput.value = '';
    // If I uploaded my images, the other user will see them; my own feed is unaffected
  });

  openSettings.addEventListener('click', () => {
    loadRepoSettings();
    settingsDialog.showModal();
  });
  settingsForm.addEventListener('submit', (e) => {
    e.preventDefault();
    saveRepoSettings();
    settingsDialog.close();
    // Reload feed in case repo changed
    loadFeed();
  });

  logoutBtn.addEventListener('click', () => {
    clearSession();
    state.me = null;
    state.other = null;
    loginScreen.classList.add('visible');
    mainScreen.classList.remove('visible');
  });

  // Boot
  loadRepoSettings();
  if(loadSession()){
    loginScreen.classList.remove('visible');
    mainScreen.classList.add('visible');
    loadFeed();
  } else {
    loginScreen.classList.add('visible');
  }
})();
  </script>
</body>
</html>
