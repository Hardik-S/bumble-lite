<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Only You</title>
  <style>
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; .hint { margin-top: 8px; color: var(--muted); }
.hint summary { cursor: pointer; }

.gesture-hint { text-align: center; font-size: 12px; color: var(--muted); margin-top: 8px; }
.keyboard-hint { text-align: center; font-size: 11px; color: var(--muted); margin-top: 4px; }
html, body { margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #0b0b0c; color: #f5f6f7; }
:root { 
  --accent: #f7b500; 
  --super-accent: #42a5f5; 
  --muted: #9aa0a6;
  --success: #4caf50;
  --danger: #f44336;
}
#app { min-height: 100svh; display: grid; place-items: stretch; }
.screen { display: none; padding: 16px; max-width: 640px; margin: 0 auto; }
.screen.visible { display: block; }

h1 { font-size: 28px; margin: 16px 0 8px; }
h2 { font-size: 18px; margin: 16px 0 8px; }
.sub { color: var(--muted); margin-bottom: 24px; }

label { display: block; font-size: 14px; margin: 8px 0 4px; color: #dfe1e5; }
input, textarea { width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #2a2a2b; background: #141416; color: #fff; resize: vertical; }
input:focus, textarea:focus { outline: 2px solid var(--accent); border-color: transparent; }

.btn { appearance: none; border: none; border-radius: 999px; padding: 12px 18px; background: #1f1f22; color: #fff; font-weight: 600; cursor: pointer; transition: all 0.2s; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn.primary { background: var(--accent); color: #191919; }
.btn.super { background: var(--super-accent); color: #fff; }
.btn.success { background: var(--success); color: #fff; }
.btn:active:not(:disabled) { transform: translateY(1px); }
.icon-btn { background: transparent; border: 1px solid #2a2a2b; border-radius: 10px; padding: 8px 10px; color: #e8eaed; cursor: pointer; }

.topbar { position: sticky; top: 0; display: flex; align-items: center; gap: 8px; padding: 8px 0 12px; background: #0b0b0c; z-index: 5; }
.brand { font-weight: 800; letter-spacing: 0.3px; }
.spacer { flex: 1; }

.content { display: grid; gap: 24px; }
.card-area { display: grid; gap: 12px; }
.card { 
  border-radius: 18px; 
  overflow: hidden; 
  border: 1px solid #2a2a2b; 
  background: #0f0f10; 
  min-height: 55svh; 
  display: grid; 
  grid-template-rows: 1fr auto; 
  touch-action: pan-y;
  position: relative;
  transition: all 0.3s ease;
}
.card.dynamic-bg {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
.card.dynamic-bg::before {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.4);
  backdrop-filter: blur(20px);
  z-index: 1;
}
.card img { 
  width: 100%; 
  height: 100%; 
  object-fit: cover; 
  background: #0b0b0c; 
  cursor: pointer;
  position: relative;
  z-index: 2;
}
.card-footer { 
  display: flex; 
  align-items: center; 
  justify-content: space-between; 
  padding: 10px 12px; 
  background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 40%, rgba(0,0,0,0.8) 100%); 
  margin-top: -72px;
  position: relative;
  z-index: 3;
}
.name-wrapper { font-weight: 700; text-shadow: 0 1px 8px rgba(0,0,0,0.7); }

.actions { display: flex; gap: 12px; justify-content: center; align-items: center; }
.muted { color: var(--muted); }
.small { font-size: 12px; }

.upload-area, .chat-area, .profile-area { border-top: 1px dashed #2a2a2b; padding-top: 16px; }

.status { min-height: 20px; font-size: 13px; color: #c4f1c4; }

/* Profile Cards */
.profile-card {
  background: #141416;
  border: 1px solid #2a2a2b;
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
}
.bio-display {
  background: #0f0f10;
  border: 1px solid #2a2a2b;
  border-radius: 8px;
  padding: 12px;
  min-height: 60px;
  color: #dfe1e5;
  white-space: pre-wrap;
  margin-bottom: 12px;
}

/* Chat Messages */
.chat-messages { 
  max-height: 300px; 
  overflow-y: auto; 
  border: 1px solid #2a2a2b; 
  border-radius: 10px; 
  padding: 12px; 
  background: #141416;
  margin-bottom: 12px;
}
.message { 
  margin-bottom: 12px; 
  padding: 8px 12px; 
  border-radius: 12px; 
  max-width: 80%;
  word-wrap: break-word;
}
.message.sent { 
  background: #2e7d32; 
  color: #fff; 
  margin-left: auto; 
  text-align: right;
}
.message.received { 
  background: #4caf50; 
  color: #fff; 
}
.message-time { 
  font-size: 10px; 
  opacity: 0.8; 
  margin-top: 4px;
}

/* Lightbox */
.lightbox { 
  position: fixed; 
  inset: 0; 
  background: rgba(0,0,0,0.95); 
  z-index: 1000; 
  display: none; 
  align-items: center; 
  justify-content: center;
  touch-action: pan-x;
}
.lightbox.visible { display: flex; }
.lightbox-content { 
  position: relative; 
  max-width: 90vw; 
  max-height: 90vh; 
  display: flex;
  align-items: center;
  justify-content: center;
}
.lightbox img { 
  max-width: 100%; 
  max-height: 100%; 
  object-fit: contain;
  border-radius: 8px;
}
.lightbox-nav { 
  position: absolute; 
  top: 50%; 
  transform: translateY(-50%); 
  background: rgba(255,255,255,0.1); 
  border: none; 
  color: #fff; 
  font-size: 24px; 
  padding: 12px; 
  border-radius: 50%; 
  cursor: pointer;
  backdrop-filter: blur(10px);
}
.lightbox-nav:hover { background: rgba(255,255,255,0.2); }
.lightbox-prev { left: 20px; }
.lightbox-next { right: 20px; }
.lightbox-close { 
  position: absolute; 
  top: 20px; 
  right: 20px; 
  background: rgba(255,255,255,0.1); 
  border: none; 
  color: #fff; 
  font-size: 24px; 
  padding: 8px 12px; 
  border-radius: 8px; 
  cursor: pointer;
  backdrop-filter: blur(10px);
}
.lightbox-counter {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.5);
  color: #fff;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 12px;
}

/* Match Modal */
.match-modal { 
  position: fixed; 
  inset: 0; 
  background: rgba(0,0,0,0.9); 
  z-index: 1001; 
  display: none; 
  align-items: center; 
  justify-content: center;
  animation: matchFadeIn 0.5s ease-out;
}
.match-modal.visible { display: flex; }
.match-content { 
  text-align: center; 
  padding: 40px 20px;
  background: linear-gradient(135deg, var(--accent), var(--super-accent));
  border-radius: 20px;
  color: #fff;
  max-width: 400px;
  margin: 20px;
}
.match-hearts { 
  font-size: 60px; 
  margin-bottom: 20px;
  animation: heartBeat 1s infinite;
}
.match-title { 
  font-size: 28px; 
  font-weight: 800; 
  margin-bottom: 12px;
}
.match-subtitle { 
  font-size: 16px; 
  opacity: 0.9; 
  margin-bottom: 30px;
}

/* Dialog */
dialog { border: 1px solid #2a2a2b; background: #111114; color: #fff; border-radius: 16px; padding: 16px; max-width: 520px; width: 92vw; }
dialog::backdrop { background: rgba(0,0,0,0.6); }
.row { display: flex; gap: 12px; margin-top: 12px; }

/* Gestures & Animations */
.swipe-right { animation: swipeR 250ms ease-out forwards; }
.super-like { animation: superLike 250ms ease-out forwards; }
@keyframes swipeR {
  to { transform: translateX(40vw) rotate(10deg); opacity: 0; }
}
@keyframes superLike {
  to { transform: translateY(-40vh) scale(1.1); opacity: 0; }
}
@keyframes matchFadeIn {
  from { opacity: 0; transform: scale(0.8); }
  to { opacity: 1; transform: scale(1); }
}
@keyframes heartBeat {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

@media (min-width: 600px) {
  .card { min-height: 60vh; }
}
  </style>
</head>
<body>
  <div id="app">
    <!-- Login Screen -->
    <section id="login-screen" class="screen visible">
      <h1>only‚Äëyou</h1>
      <p class="sub">A private space for two hearts.</p>
      <form id="login-form">
        <label>Username</label>
        <input id="username" name="username" autocomplete="username" placeholder="hardik or ananya" required />
        <label>Password</label>
        <input id="password" name="password" type="password" autocomplete="current-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" required />
        <button type="submit" class="btn primary">Log in</button>
      </form>
      <details class="hint">
        <summary>Hint</summary>
        <div><code>hardik / iloveananya</code> or <code>ananya / ilovehardik</code></div>
      </details>
    </section>

    <!-- Main App -->
    <section id="main-screen" class="screen">
      <header class="topbar">
        <div class="brand">only‚Äëyou</div>
        <div class="spacer"></div>
        <button id="open-settings" aria-label="Settings" class="icon-btn">‚öôÔ∏è</button>
        <button id="logout" class="icon-btn" aria-label="Log out">üö™</button>
      </header>

      <div class="content">
        <div class="card-area">
          <div id="card" class="card" tabindex="0" aria-live="polite">
            <img id="card-img" alt="Profile image" />
            <div class="card-footer">
              <div class="name-wrapper">
                <span id="other-username"></span>
              </div>
            </div>
          </div>
          <div class="actions">
            <button id="like-btn" class="btn primary" disabled>‚ù§Ô∏è Like</button>
            <button id="super-like-btn" class="btn super" disabled>‚≠ê Super Like</button>
            <button id="next-btn" class="btn" disabled>Next</button>
          </div>
          <div class="gesture-hint">Swipe right to like ‚Ä¢ Swipe up for super like</div>
          <div class="keyboard-hint">Keyboard: ‚Üí (like) ‚Ä¢ ‚Üë (super like) ‚Ä¢ ‚Üì (next)</div>
          <div id="empty-feed" class="muted" hidden>No images yet. Ask the other user to upload!</div>
        </div>

        <div class="profile-area">
          <h2>Your Profile</h2>
          <div class="profile-card">
            <label>Bio
              <textarea id="bio-input" placeholder="Tell them about yourself..." rows="3" maxlength="500"></textarea>
            </label>
            <div class="row">
              <button id="save-bio-btn" class="btn primary">Save Bio</button>
              <span id="bio-status" class="status"></span>
            </div>
          </div>
          
          <h3><span id="their-name"></span>'s Profile</h3>
          <div class="profile-card">
            <div id="their-bio" class="bio-display">No bio yet...</div>
            <button id="refresh-bio-btn" class="btn">Refresh</button>
          </div>
        </div>

        <div class="chat-area">
          <h2>Chat with <span id="chat-partner"></span></h2>
          <div id="chat-messages" class="chat-messages"></div>
          <div class="row">
            <textarea id="chat-input" placeholder="Type a message..." rows="2"></textarea>
            <button id="send-btn" class="btn primary">Send</button>
          </div>
          <div id="chat-status" class="status"></div>
        </div>

        <div class="upload-area">
          <h2>Upload your photos</h2>
          <input id="file-input" type="file" accept="image/*" multiple />
          <button id="upload-btn" class="btn">Upload</button>
          <div class="muted small">Images up to 5MB will be auto-compressed to fit GitHub's 1MB limit. Saved to <code>/images/&lt;your-username&gt;/</code> in your GitHub repo if a token is configured. Otherwise stored locally only.</div>
          <div id="upload-status" class="status"></div>
        </div>
      </div>
    </section>

    <!-- Lightbox -->
    <div id="lightbox" class="lightbox">
      <div class="lightbox-content">
        <img id="lightbox-img" alt="Full size image" />
        <button id="lightbox-prev" class="lightbox-nav lightbox-prev">‚Äπ</button>
        <button id="lightbox-next" class="lightbox-nav lightbox-next">‚Ä∫</button>
        <button id="lightbox-close" class="lightbox-close">‚úï</button>
        <div id="lightbox-counter" class="lightbox-counter">1 / 1</div>
      </div>
    </div>

    <!-- Match Modal -->
    <div id="match-modal" class="match-modal">
      <div class="match-content">
        <div class="match-hearts">üíï</div>
        <div class="match-title">It's a Match!</div>
        <div class="match-subtitle">You and <span id="match-username"></span> liked each other</div>
        <button id="match-close" class="btn success">Start Chatting</button>
      </div>
    </div>

    <!-- Settings Modal -->
    <dialog id="settings-dialog">
      <form method="dialog" id="settings-form">
        <h3>Repository Settings</h3>
        <label>Owner (user/org)
          <input id="gh-owner" placeholder="your-github-username" required />
        </label>
        <label>Repo
          <input id="gh-repo" placeholder="your-repo-name" required />
        </label>
        <label>Branch
          <input id="gh-branch" placeholder="main" value="main" required />
        </label>
        <label>GitHub Token (fine-grained with Contents: Read &amp; Write for this repo)
          <input id="gh-token" type="password" placeholder="ghp_..." />
        </label>
        <div class="row">
          <button type="submit" class="btn primary">Save</button>
          <button value="cancel" class="btn">Close</button>
        </div>
        <p class="muted small">Token is stored in <code>localStorage</code> on this device only.</p>
      </form>
    </dialog>
  </div>

  <script>
// only-you front-end
(function(){
  const el = (id) => document.getElementById(id);
  const loginScreen = el('login-screen');
  const mainScreen = el('main-screen');
  const loginForm = el('login-form');
  const usernameInput = el('username');
  const passwordInput = el('password');
  const otherUsername = el('other-username');
  const chatPartner = el('chat-partner');
  const likeBtn = el('like-btn');
  const superLikeBtn = el('super-like-btn');
  const nextBtn = el('next-btn');
  const card = el('card');
  const cardImg = el('card-img');
  const emptyFeed = el('empty-feed');
  const fileInput = el('file-input');
  const uploadBtn = el('upload-btn');
  const uploadStatus = el('upload-status');
  const openSettings = el('open-settings');
  const settingsDialog = el('settings-dialog');
  const settingsForm = el('settings-form');
  const ghOwner = el('gh-owner');
  const ghRepo = el('gh-repo');
  const ghBranch = el('gh-branch');
  const ghToken = el('gh-token');
  const logoutBtn = el('logout');
  
  // Lightbox elements
  const lightbox = el('lightbox');
  const lightboxImg = el('lightbox-img');
  const lightboxPrev = el('lightbox-prev');
  const lightboxNext = el('lightbox-next');
  const lightboxClose = el('lightbox-close');
  const lightboxCounter = el('lightbox-counter');
  
  // Match modal elements
  const matchModal = el('match-modal');
  const matchUsername = el('match-username');
  const matchClose = el('match-close');
  
  const chatMessages = el('chat-messages');
  const chatInput = el('chat-input');
  const sendBtn = el('send-btn');
  const chatStatus = el('chat-status');
  
  // Profile elements
  const bioInput = el('bio-input');
  const saveBioBtn = el('save-bio-btn');
  const bioStatus = el('bio-status');
  const theirName = el('their-name');
  const theirBio = el('their-bio');
  const refreshBioBtn = el('refresh-bio-btn');

  // --- App State ---
  let state = {
    me: null,                // 'hardik' | 'ananya'
    other: null,             // opposite of 'me'
    feed: [],                // array of image URLs
    feedIdx: 0,              // current index
    lightboxIdx: 0,          // current lightbox index
    repo: { owner: '', repo: '', branch: 'main', token: '' }
  };

  // Try to infer owner/repo from GitHub Pages URL
  function inferRepoFromLocation(){
    // https://<owner>.github.io/<repo>/...
    const { host, pathname } = window.location;
    const m = host.match(/^([^.]+)\.github\.io$/);
    const pathParts = pathname.replace(/^\//,'').split('/').filter(Boolean);
    if(m && pathParts.length){
      return { owner: m[1], repo: pathParts[0] };
    }
    return null;
  }

  // Load repo settings from localStorage
  function loadRepoSettings(){
    const saved = localStorage.getItem('onlyYouRepoCfg');
    if(saved){
      try { state.repo = JSON.parse(saved); } catch(e){}
    } else {
      const inferred = inferRepoFromLocation();
      state.repo = {
        owner: inferred?.owner || '',
        repo: inferred?.repo || '',
        branch: 'main',
        token: ''
      };
    }
    ghOwner.value = state.repo.owner || '';
    ghRepo.value = state.repo.repo || '';
    ghBranch.value = state.repo.branch || 'main';
    ghToken.value = state.repo.token || '';
  }
  function saveRepoSettings(){
    state.repo.owner = ghOwner.value.trim();
    state.repo.repo = ghRepo.value.trim();
    state.repo.branch = ghBranch.value.trim() || 'main';
    state.repo.token = ghToken.value.trim();
    localStorage.setItem('onlyYouRepoCfg', JSON.stringify(state.repo));
  }

  // --- Auth (two fixed accounts) ---
  const USERS = {
    'hardik': 'iloveananya',
    'ananya': 'ilovehardik'
  };
  function persistSession(){
    localStorage.setItem('onlyYouSession', JSON.stringify({ me: state.me, ts: Date.now() }));
  }
  function loadSession(){
    try{
      const s = JSON.parse(localStorage.getItem('onlyYouSession')||'null');
      if(s?.me && USERS[s.me]){
        state.me = s.me;
        state.other = (state.me === 'hardik') ? 'ananya' : 'hardik';
        return true;
      }
    } catch(e){}
    return false;
  }
  function clearSession(){
    localStorage.removeItem('onlyYouSession');
  }

  // --- Likes & Matches ---
  function getLikes(user, type = 'likes') {
    const key = `${type}_${user}`;
    return JSON.parse(localStorage.getItem(key) || '[]');
  }
  
  function addLike(user, imageUrl, type = 'likes') {
    const key = `${type}_${user}`;
    const likes = getLikes(user, type);
    if (!likes.includes(imageUrl)) {
      likes.push(imageUrl);
      localStorage.setItem(key, JSON.stringify(likes));
      
      // Check for mutual like (match)
      if (type === 'likes') {
        const theirLikes = getLikes(state.other, 'likes');
        const myImages = JSON.parse(localStorage.getItem(`localImages_${state.me}`) || '[]');
        
        // Check if they liked any of my images and I just liked theirs
        const hasMatch = theirLikes.some(likedImg => {
          return myImages.includes(likedImg);
        });
        
        if (hasMatch) {
          showMatchModal();
        }
      }
    }
  }
  
  function showMatchModal() {
    matchUsername.textContent = state.other;
    matchModal.classList.add('visible');
  }
  
  function hideMatchModal() {
    matchModal.classList.remove('visible');
  }

  // --- Image compression utilities ---
  function compressImage(file, maxSizeKB = 1000, quality = 0.8) {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        // Calculate new dimensions to stay under size limit
        let { width, height } = img;
        const maxDim = 1920; // Max dimension
        
        if (width > maxDim || height > maxDim) {
          if (width > height) {
            height = (height * maxDim) / width;
            width = maxDim;
          } else {
            width = (width * maxDim) / height;
            height = maxDim;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        
        ctx.drawImage(img, 0, 0, width, height);
        
        // Try different quality levels to stay under size limit
        const tryCompress = (q) => {
          canvas.toBlob((blob) => {
            if (blob && blob.size <= maxSizeKB * 1024) {
              // Convert blob back to File
              const compressedFile = new File([blob], file.name, {
                type: blob.type,
                lastModified: Date.now()
              });
              resolve(compressedFile);
            } else if (q > 0.1) {
              tryCompress(q - 0.1);
            } else {
              // If we can't compress enough, return original
              resolve(file);
            }
          }, file.type, q);
        };
        
        tryCompress(quality);
      };
      
      img.src = URL.createObjectURL(file);
    });
  }

  // --- GitHub API helpers ---
  const GH_API = 'https://api.github.com';

  async function githubSaveTextFile(filename, content) {
    if (!state.repo.token || !state.repo.owner || !state.repo.repo) {
      throw new Error('GitHub configuration required');
    }
    
    const path = filename;
    const url = `${GH_API}/repos/${state.repo.owner}/${state.repo.repo}/contents/${encodeURIComponent(path)}`;
    
    // First, try to get the current file to get its SHA
    let sha = null;
    try {
      const getResp = await fetch(url, {
        headers: { 
          'Accept': 'application/vnd.github+json',
          'Authorization': `Bearer ${state.repo.token}`
        }
      });
      if (getResp.ok) {
        const data = await getResp.json();
        sha = data.sha;
      }
    } catch(e) {
      // File doesn't exist yet, that's okay
    }
    
    const body = {
      message: `Update ${filename}`,
      content: btoa(unescape(encodeURIComponent(content))), // Proper UTF-8 encoding
      branch: state.repo.branch
    };
    
    if (sha) {
      body.sha = sha; // Required for updates
    }
    
    const resp = await fetch(url, {
      method: 'PUT',
      headers: {
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.repo.token}`
      },
      body: JSON.stringify(body)
    });
    
    if (!resp.ok) {
      const t = await resp.text();
      throw new Error(`GitHub save failed: ${resp.status} ${t}`);
    }
    return true;
  }
  
  async function githubLoadTextFile(filename) {
    if (!state.repo.owner || !state.repo.repo) {
      return null;
    }
    
    const url = `${GH_API}/repos/${state.repo.owner}/${state.repo.repo}/contents/${encodeURIComponent(filename)}?r=${Date.now()}`;
    const headers = { 'Accept': 'application/vnd.github+json' };
    
    if (state.repo.token) {
      headers['Authorization'] = `Bearer ${state.repo.token}`;
    }
    
    const resp = await fetch(url, { headers });
    
    if (resp.status === 404) {
      return null; // File doesn't exist
    }
    
    if (!resp.ok) {
      throw new Error(`GitHub load failed: ${resp.status}`);
    }
    
    const data = await resp.json();
    return decodeURIComponent(escape(atob(data.content))); // Proper UTF-8 decoding
  }

  async function githubListImages(user){
    const path = `images/${user}`;
    if(!state.repo.owner || !state.repo.repo){
      // No repo configured, try local fallback
      return listLocalImages(user);
    }
    const url = `${GH_API}/repos/${state.repo.owner}/${state.repo.repo}/contents/${encodeURIComponent(path)}?r=${Date.now()}`;
    const resp = await fetch(url, { headers: { 'Accept': 'application/vnd.github+json' } });
    if(resp.status === 404){
      return []; // folder not found yet
    }
    if(!resp.ok){
      console.warn('GitHub list error', resp.status);
      throw new Error('Failed to list images from GitHub');
    }
    const data = await resp.json();
    // Filter images and map to download_url
    return (Array.isArray(data) ? data : [])
      .filter(it => /(\.png|\.jpg|\.jpeg|\.webp|\.gif)$/i.test(it.name))
      .map(it => it.download_url);
  }

  async function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error('Read error'));
      reader.onload = () => {
        const res = reader.result || '';
        // res is like "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ..."
        const base64 = String(res).split(',')[1] || '';
        resolve(base64);
      };
      reader.readAsDataURL(file);
    });
  }
  
  async function githubUploadImage(user, file){
    if(!state.repo.token || !state.repo.owner || !state.repo.repo){
      // local fallback only
      return localSave(user, file);
    }
    
    // Compress image if it's too large
    let processedFile = file;
    if (file.size > 1000 * 1024) { // If larger than 1MB
      uploadStatus.textContent = 'Compressing image...';
      processedFile = await compressImage(file);
    }
    
    const base64 = await fileToBase64(processedFile);
    const safeName = `${Date.now()}-${file.name.replace(/[^a-z0-9_.-]/gi,'_')}`;
    const path = `images/${user}/${safeName}`;
    const url = `${GH_API}/repos/${state.repo.owner}/${state.repo.repo}/contents/${encodeURIComponent(path)}`;
    const body = {
      message: `chore: add ${user} image ${safeName}`,
      content: base64,
      branch: state.repo.branch
    };
    const resp = await fetch(url, {
      method: 'PUT',
      headers: {
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.repo.token}`
      },
      body: JSON.stringify(body)
    });
    if(!resp.ok){
      const t = await resp.text();
      throw new Error(`GitHub upload failed: ${resp.status} ${t}`);
    }
    return true;
  }

  // Local fallback (non-persistent to GitHub; stays in this browser)
  function localKey(user){ return `localImages_${user}`; }
  async function localSave(user, file){
    const reader = new FileReader();
    const res = await new Promise((resolve, reject) => {
      reader.onerror = () => reject(new Error('Read error'));
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });
    const arr = JSON.parse(localStorage.getItem(localKey(user)) || '[]');
    arr.push(res);
    localStorage.setItem(localKey(user), JSON.stringify(arr));
    return true;
  }
  function listLocalImages(user){
    const arr = JSON.parse(localStorage.getItem(localKey(user)) || '[]');
    return arr;
  }

  // --- Dynamic card backgrounds ---
  function updateCardBackground(imageUrl) {
    if (!imageUrl) {
      card.classList.remove('dynamic-bg');
      card.style.backgroundImage = '';
      return;
    }
    
    card.classList.add('dynamic-bg');
    card.style.backgroundImage = `url(${imageUrl})`;
  }

  // --- Feed logic ---
  async function loadFeed(){
    otherUsername.textContent = state.other;
    chatPartner.textContent = state.other;
    theirName.textContent = state.other;
    try {
      const imgs = await githubListImages(state.other);
      state.feed = imgs;
      state.feedIdx = 0;
      renderCard();
      updateButtonStates();
    } catch(e){
      console.error(e);
      state.feed = [];
      state.feedIdx = 0;
      renderCard();
      updateButtonStates();
    }
  }

  function renderCard(){
    if(!state.feed.length || state.feedIdx >= state.feed.length){
      cardImg.removeAttribute('src');
      emptyFeed.hidden = false;
      updateCardBackground(null);
      return;
    }
    emptyFeed.hidden = true;
    const currentImg = state.feed[state.feedIdx];
    cardImg.src = currentImg;
    updateCardBackground(currentImg);
  }
  
  function updateButtonStates() {
    const hasImages = state.feed.length > 0 && state.feedIdx < state.feed.length;
    likeBtn.disabled = !hasImages;
    superLikeBtn.disabled = !hasImages;
    nextBtn.disabled = !hasImages;
  }

  function nextCard(){
    state.feedIdx = Math.min(state.feedIdx + 1, state.feed.length);
    renderCard();
    updateButtonStates();
  }

  function likeCurrent(isSuper = false){
    if(!state.feed.length || state.feedIdx >= state.feed.length) return;
    const img = state.feed[state.feedIdx];
    
    // Store like locally per user
    const type = isSuper ? 'superlikes' : 'likes';
    addLike(state.me, img, type);

    // Animate and go next
    const animClass = isSuper ? 'super-like' : 'swipe-right';
    card.classList.remove('swipe-right', 'super-like');
    void card.offsetWidth; // reflow
    card.classList.add(animClass);
    setTimeout(() => {
      card.classList.remove(animClass);
      nextCard();
    }, 250);
  }

  // --- Lightbox functionality ---
  function openLightbox(startIdx = 0) {
    if (!state.feed.length) return;
    state.lightboxIdx = startIdx;
    updateLightboxImage();
    lightbox.classList.add('visible');
    document.body.style.overflow = 'hidden';
  }
  
  function closeLightbox() {
    lightbox.classList.remove('visible');
    document.body.style.overflow = '';
  }
  
  function updateLightboxImage() {
    if (state.lightboxIdx < 0) state.lightboxIdx = 0;
    if (state.lightboxIdx >= state.feed.length) state.lightboxIdx = state.feed.length - 1;
    
    lightboxImg.src = state.feed[state.lightboxIdx];
    lightboxCounter.textContent = `${state.lightboxIdx + 1} / ${state.feed.length}`;
    
    lightboxPrev.style.display = state.lightboxIdx > 0 ? 'block' : 'none';
    lightboxNext.style.display = state.lightboxIdx < state.feed.length - 1 ? 'block' : 'none';
  }
  
  function prevLightboxImage() {
    if (state.lightboxIdx > 0) {
      state.lightboxIdx--;
      updateLightboxImage();
    }
  }
  
  function nextLightboxImage() {
    if (state.lightboxIdx < state.feed.length - 1) {
      state.lightboxIdx++;
      updateLightboxImage();
    }
  }

  // --- Bio/Profile functionality ---
  async function saveBio() {
    const bioText = bioInput.value.trim();
    bioStatus.textContent = 'Saving bio...';
    
    try {
      if (state.repo.token) {
        // Save to GitHub
        await githubSaveTextFile(`profiles/${state.me}_bio.txt`, bioText);
        bioStatus.textContent = 'Bio saved to GitHub!';
      } else {
        // Save locally
        localStorage.setItem(`bio_${state.me}`, bioText);
        bioStatus.textContent = 'Bio saved locally (not synced)';
      }
    } catch (err) {
      console.error('Bio save error:', err);
      bioStatus.textContent = 'Failed to save bio';
    }
  }
  
  async function loadMyBio() {
    try {
      let bioText = '';
      if (state.repo.owner && state.repo.repo) {
        // Try to load from GitHub first
        bioText = await githubLoadTextFile(`profiles/${state.me}_bio.txt`);
      }
      
      if (!bioText) {
        // Fallback to local storage
        bioText = localStorage.getItem(`bio_${state.me}`) || '';
      }
      
      bioInput.value = bioText;
    } catch (err) {
      console.error('Failed to load bio:', err);
      bioInput.value = localStorage.getItem(`bio_${state.me}`) || '';
    }
  }
  
  async function loadTheirBio() {
    try {
      let bioText = '';
      if (state.repo.owner && state.repo.repo) {
        // Try to load from GitHub
        bioText = await githubLoadTextFile(`profiles/${state.other}_bio.txt`);
      }
      
      if (!bioText) {
        // Try local storage as fallback (though this won't work across devices)
        bioText = localStorage.getItem(`bio_${state.other}`) || '';
      }
      
      theirBio.textContent = bioText || 'No bio yet...';
    } catch (err) {
      console.error('Failed to load their bio:', err);
      theirBio.textContent = 'Failed to load bio';
    }
  }

  // --- Chat functionality ---
  async function loadChatMessages() {
    chatMessages.innerHTML = '';
    
    try {
      let chatText = '';
      if (state.repo.owner && state.repo.repo) {
        // Try to load from GitHub
        chatText = await githubLoadTextFile(`chat/${state.me}_${state.other}.txt`) || 
                   await githubLoadTextFile(`chat/${state.other}_${state.me}.txt`) || '';
      }
      
      if (!chatText) {
        // Fallback to local storage
        chatText = localStorage.getItem(`chat_${state.me}_${state.other}`) || 
                   localStorage.getItem(`chat_${state.other}_${state.me}`) || '';
      }
      
      if (chatText) {
        const messages = chatText.split('\n').filter(line => line.trim());
        messages.forEach(line => {
          const match = line.match(/^\[([^\]]+)\] ([^:]+): (.+)$/);
          if (match) {
            const [, timestamp, from, text] = match;
            displayMessage(from, text, new Date(timestamp));
          }
        });
      }
      
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (err) {
      console.error('Failed to load chat:', err);
      chatStatus.textContent = 'Failed to load chat history';
    }
  }
  
  function displayMessage(from, text, timestamp) {
    const div = document.createElement('div');
    div.className = `message ${from === state.me ? 'sent' : 'received'}`;
    
    const textEl = document.createElement('div');
    textEl.textContent = text;
    
    const timeEl = document.createElement('div');
    timeEl.className = 'message-time';
    timeEl.textContent = timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    
    div.appendChild(textEl);
    div.appendChild(timeEl);
    chatMessages.appendChild(div);
  }
  
  async function sendMessage() {
    const text = chatInput.value.trim();
    if (!text) return;
    
    const timestamp = new Date();
    const messageLine = `[${timestamp.toISOString()}] ${state.me}: ${text}`;
    
    // Display immediately
    displayMessage(state.me, text, timestamp);
    chatInput.value = '';
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Save to storage
    try {
      if (state.repo.token) {
        // Load existing chat, append new message, save back
        chatStatus.textContent = 'Sending...';
        const filename = `chat/${state.me}_${state.other}.txt`;
        let existingChat = await githubLoadTextFile(filename) || '';
        const newChat = existingChat + (existingChat ? '\n' : '') + messageLine;
        await githubSaveTextFile(filename, newChat);
        chatStatus.textContent = 'Message sent!';
        setTimeout(() => chatStatus.textContent = '', 2000);
      } else {
        // Save locally (won't sync between users without GitHub)
        const key = `chat_${state.me}_${state.other}`;
        const existing = localStorage.getItem(key) || '';
        const newChat = existing + (existing ? '\n' : '') + messageLine;
        localStorage.setItem(key, newChat);
        chatStatus.textContent = 'Message saved locally (not synced)';
        setTimeout(() => chatStatus.textContent = '', 2000);
      }
    } catch (err) {
      console.error('Failed to save message:', err);
      chatStatus.textContent = 'Failed to send message';
      setTimeout(() => chatStatus.textContent = '', 3000);
    }
  }

  // --- Touch gestures (right swipe and swipe up for super like) ---
  let touchStartX = null, touchStartY = null;
  let lightboxTouchStartX = null;
  
  card.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    touchStartX = t.clientX; 
    touchStartY = t.clientY;
  }, {passive: true});
  
  card.addEventListener('touchend', (e) => {
    if (likeBtn.disabled) return; // Don't process gestures when deck is empty
    
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = touchStartY - t.clientY; // Inverted for upward swipe
    const horizontalDistance = Math.abs(dx);
    const verticalDistance = Math.abs(dy);
    
    if (dy > 60 && verticalDistance > horizontalDistance) {
      // Swipe up for super like
      likeCurrent(true);
    } else if (dx > 40 && horizontalDistance > verticalDistance) {
      // Right swipe for regular like
      likeCurrent(false);
    }
  }, {passive: true});
  
  // Lightbox touch gestures
  lightbox.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    lightboxTouchStartX = t.clientX;
  }, {passive: true});
  
  lightbox.addEventListener('touchend', (e) => {
    const t = e.changedTouches[0];
    const dx = t.clientX - lightboxTouchStartX;
    
    if (Math.abs(dx) > 50) {
      if (dx > 0) {
        prevLightboxImage();
      } else {
        nextLightboxImage();
      }
    }
  }, {passive: true});

  // --- Keyboard shortcuts ---
  document.addEventListener('keydown', (e) => {
    if (lightbox.classList.contains('visible')) {
      // Lightbox controls
      if (e.key === 'Escape') {
        closeLightbox();
      } else if (e.key === 'ArrowLeft') {
        prevLightboxImage();
      } else if (e.key === 'ArrowRight') {
        nextLightboxImage();
      }
      return;
    }
    
    if (matchModal.classList.contains('visible')) {
      if (e.key === 'Escape' || e.key === 'Enter') {
        hideMatchModal();
      }
      return;
    }
    
    // Main app keyboard shortcuts
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
      return; // Don't interfere with text input
    }
    
    if (e.key === 'ArrowRight') {
      if (!likeBtn.disabled) likeCurrent(false);
    } else if (e.key === 'ArrowUp') {
      if (!superLikeBtn.disabled) likeCurrent(true);
    } else if (e.key === 'ArrowDown') {
      if (!nextBtn.disabled) nextCard();
    }
  });

  // --- UI Events ---
  loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const u = usernameInput.value.trim().toLowerCase();
    const p = passwordInput.value;
    if(USERS[u] && USERS[u] === p){
      state.me = u;
      state.other = (u === 'hardik') ? 'ananya' : 'hardik';
      persistSession();
      loginScreen.classList.remove('visible');
      mainScreen.classList.add('visible');
      loadFeed();
      loadChatMessages();
      loadMyBio();
      loadTheirBio();
    } else {
      alert('Invalid credentials');
    }
  });

  likeBtn.addEventListener('click', () => likeCurrent(false));
  superLikeBtn.addEventListener('click', () => likeCurrent(true));
  nextBtn.addEventListener('click', nextCard);
  
  // Image tap to open lightbox
  cardImg.addEventListener('click', () => {
    if (state.feed.length > 0 && state.feedIdx < state.feed.length) {
      openLightbox(state.feedIdx);
    }
  });
  
  // Lightbox controls
  lightboxClose.addEventListener('click', closeLightbox);
  lightboxPrev.addEventListener('click', prevLightboxImage);
  lightboxNext.addEventListener('click', nextLightboxImage);
  
  // Match modal
  matchClose.addEventListener('click', hideMatchModal);
  
  // Chat
  sendBtn.addEventListener('click', sendMessage);
  chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
  
  // Profile/Bio
  saveBioBtn.addEventListener('click', saveBio);
  refreshBioBtn.addEventListener('click', loadTheirBio);

  uploadBtn.addEventListener('click', async () => {
    if(!state.me){ alert('Please log in first'); return; }
    const files = fileInput.files;
    if(!files || !files.length){ alert('Pick image(s) first'); return; }
    
    // Check file sizes
    const oversizedFiles = Array.from(files).filter(file => file.size > 5 * 1024 * 1024); // 5MB limit
    if (oversizedFiles.length > 0) {
      alert(`Some files are too large (>5MB): ${oversizedFiles.map(f => f.name).join(', ')}`);
      return;
    }
    
    uploadStatus.textContent = 'Uploading...';
    let ok = 0, fail = 0;
    for(const file of files){
      try{
        await githubUploadImage(state.me, file);
        ok++;
        uploadStatus.textContent = `Uploaded ${ok}/${files.length} files...`;
      } catch(err){
        console.error(err);
        fail++;
      }
    }
    uploadStatus.textContent = (state.repo.token && state.repo.owner && state.repo.repo)
      ? `Uploaded ${ok} file(s) to GitHub. ${fail ? fail+' failed.' : ''}`
      : `Saved ${ok} locally (no GitHub token configured). ${fail ? fail+' failed.' : ''}`;
    fileInput.value = '';
    // If I uploaded my images, the other user will see them; my own feed is unaffected
  });

  openSettings.addEventListener('click', () => {
    loadRepoSettings();
    settingsDialog.showModal();
  });
  settingsForm.addEventListener('submit', (e) => {
    e.preventDefault();
    saveRepoSettings();
    settingsDialog.close();
    // Reload feed in case repo changed
    loadFeed();
  });

  logoutBtn.addEventListener('click', () => {
    clearSession();
    state.me = null;
    state.other = null;
    loginScreen.classList.add('visible');
    mainScreen.classList.remove('visible');
  });

  // Boot
  loadRepoSettings();
  if(loadSession()){
    loginScreen.classList.remove('visible');
    mainScreen.classList.add('visible');
    loadFeed();
    loadChatMessages();
    loadMyBio();
    loadTheirBio();
  } else {
    loginScreen.classList.add('visible');
  }
})();
  </script>
</body>
</html>
